# C++ 1   
在查看区块生产部分的代码，即producer_plugin.cpp时，遇到了如下代码
```C++
incoming::channels::block::channel_type::handle			_incoming_block_subscription;
incoming::channels::transaction::channel_type::handle		_incoming_transaction_subscription;

compat::channels::transaction_ack::channel_type&		_transaction_ack_channel;

incoming::methods::block_sync::method_type::handle		_incoming_block_sync_provider;
incoming::methods::transaction_async::method_type::handle	_incoming_transaction_async_provider;
```

于是转到channels.hpp查看channel数据结构以及其子分类handle             
在阅读class channel定义时发现如下代码：
```C++
using ios_ptr_type = std::shared_ptr<boost::asio::io_service>;

using handle_type = boost::signals2::connection;
```
于是查看C++中`shared_ptr`以及`boost::signals2::connection`的相关定义，结果如下：
                             
			     
## std::shared_ptr
* shared_ptr是通过指针保持对象共享所有权的智能指针，多个shared_ptr可共享同一对象。           
换句话说，多个shared_ptr管理同一个裸指针raw_ptr
* 通过引用计数实现，所有shared_ptr共享一个引用计数器，当引用计数器值为0时，释放指针指向的资源
* 为保证线程安全性，引用计时器的加一，减一都是原子操作，保证shared_ptr由多个线程共享时不会出错
         
使用举例：
```C++
//make_shared: 分配内存，并初始化为100，返回值为shared_ptr
shared_ptr<int> sp = make_shared<int>(100);

//new: 直接初始化指针
shared_ptr<int> sp1(new int(100);

//关联指针
//关联结果：sp1,, sp2, sp3共享内存，sp4独立于sp1,sp2,sp3
shared_ptr<int> sp1(new int(10));
shared_ptr<int> sp2(sp1), sp3;		//使用sp1初始化sp2
sp3 = sp1;				//直接将sp1赋值为sp3
shared_ptr<int> sp4(sp1.get());		//使用sp1保存的指针初始化sp4
```
               
	       
## boost::signals2
* 实现了线程安全的观察者模式，即siganl/slot
* 函数回调机制，一个信号关联多个插槽，当信号发出时，所有关联的插槽都会被调用

### 操作函数
1.  connect          
将插槽连接到信号上，连接成功将返回一个connection对象，表示连接关系             

使用举例：
```C++
boost::signals2::signal<void()>	sig;
sig.connect(&slots1);
sig.connect(&slots2);

sig();
```
